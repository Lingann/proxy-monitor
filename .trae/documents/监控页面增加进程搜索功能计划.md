# 监控页面进程搜索功能实现计划

我将分三步在监控页面实现进程搜索功能：

## 1. 修改页面结构 (`monitor.ejs`)
在“进程列表”标题栏处创建一个 Flex 容器，将标题和新的搜索框容器并排显示。

```html
<!-- 修改前 -->
<h2><%= t('monitor.processes') %></h2>

<!-- 修改后 -->
<div class="process-section-header">
    <h2><%= t('monitor.processes') %></h2>
    <div id="processSearchContainer" style="width: 250px;"></div>
</div>
```

## 2. 添加样式 (`monitor.css`)
为新的标题栏容器添加 Flex 布局样式，确保标题在左，搜索框在右。

```css
.process-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}
```

## 3. 实现搜索逻辑 (`monitor.ts`)
1.  **引入组件**: 导入 `CommonSearchInput`。
2.  **初始化组件**: 在 `initMonitor` 函数中初始化搜索组件，绑定到 `#processSearchContainer`。
3.  **实现过滤**:
    *   在 `onSearch` 回调中获取用户输入的关键词（PID 或 名称）。
    *   修改 `updateProcessTable` 函数，在渲染表格前根据关键词过滤进程数据。

```typescript
// 伪代码逻辑
let currentSearchTerm = '';

// 初始化搜索框
const searchInput = new CommonSearchInput('processSearchContainer', {
    placeholder: 'PID / Name', // 将使用翻译键或默认文本
    enableDropdown: false,
    onSearch: (term) => {
        currentSearchTerm = term.toLowerCase();
        // 触发重新渲染
        if (currentData) updateProcessTable(currentData);
    }
});

// 更新过滤逻辑
function updateProcessTable(data) {
    let processes = data.processes;
    if (currentSearchTerm) {
        processes = processes.filter(p => 
            p.name.toLowerCase().includes(currentSearchTerm) || 
            p.pid.toString().includes(currentSearchTerm)
        );
    }
    processTable.setData(processes, true);
}
```